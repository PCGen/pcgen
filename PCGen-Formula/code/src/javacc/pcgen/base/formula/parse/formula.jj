/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. formula.jj */
/*@egen*//*
 * Copyright 2014-16 (C) Tom Parker <thpr@users.sourceforge.net>
 * Copyright (c) Andrew Wilson, 2010.
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
options {
  STATIC=false;
               
             
}

PARSER_BEGIN( FormulaParser )
package pcgen.base.formula.parse;

public class FormulaParser/*@bgen(jjtree)*/implements FormulaParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTFormulaParserState jjtree = new JJTFormulaParserState();

/*@egen*/
}
PARSER_END( FormulaParser )

SimpleNode query()
	      : {/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
	{/*@bgen(jjtree) Root */
                try {
/*@egen*/ 
		( logicalExpr() )? <EOF>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ return jjtn000; }/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/ 
	}

/******************************************************************************
 * Add Logical expression and function
 *****************************************************************************/
void logicalExpr()
	      : { Operator image; }
	{
		equalityExpr()
		(
			image = logicalFtn()/*@bgen(jjtree) #Logical( 2) */
                                             {
                                               ASTLogical jjtn001 = new ASTLogical(JJTLOGICAL);
                                               boolean jjtc001 = true;
                                               jjtree.openNodeScope(jjtn001);
                                             }
                                             try {
/*@egen*/ equalityExpr()/*@bgen(jjtree)*/
                                             } catch (Throwable jjte001) {
                                               if (jjtc001) {
                                                 jjtree.clearNodeScope(jjtn001);
                                                 jjtc001 = false;
                                               } else {
                                                 jjtree.popNode();
                                               }
                                               if (jjte001 instanceof RuntimeException) {
                                                 throw (RuntimeException)jjte001;
                                               }
                                               if (jjte001 instanceof ParseException) {
                                                 throw (ParseException)jjte001;
                                               }
                                               throw (Error)jjte001;
                                             } finally {
                                               if (jjtc001) {
                                                 jjtree.closeNodeScope(jjtn001,  2);
                                               }
                                             }
/*@egen*/            
			{ ((SimpleNode) jjtree.peekNode()).setOperator(image); }
		)*
	}

Operator logicalFtn()
	      : { Operator image; }
	{
		(
			image = orToken() |
			image = andToken()
		)
		{ return image; } 
	}

Operator orToken()
	      : {}
	{
		<OR>
		{ return Operator.OR; }
	}

Operator andToken()
	      : {}
	{
		<AND>
		{ return Operator.AND; }
	}

/******************************************************************************
 * Add Equality expression and functions
 *****************************************************************************/
void equalityExpr()
	      : { Operator image; }
	{ 
		relationalExpr()
		(
			image = equalityFtn()/*@bgen(jjtree) #Equality( 2) */
                                              {
                                                ASTEquality jjtn001 = new ASTEquality(JJTEQUALITY);
                                                boolean jjtc001 = true;
                                                jjtree.openNodeScope(jjtn001);
                                              }
                                              try {
/*@egen*/ relationalExpr()/*@bgen(jjtree)*/
                                              } catch (Throwable jjte001) {
                                                if (jjtc001) {
                                                  jjtree.clearNodeScope(jjtn001);
                                                  jjtc001 = false;
                                                } else {
                                                  jjtree.popNode();
                                                }
                                                if (jjte001 instanceof RuntimeException) {
                                                  throw (RuntimeException)jjte001;
                                                }
                                                if (jjte001 instanceof ParseException) {
                                                  throw (ParseException)jjte001;
                                                }
                                                throw (Error)jjte001;
                                              } finally {
                                                if (jjtc001) {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                }
                                              }
/*@egen*/             
			{ ((SimpleNode) jjtree.peekNode()).setOperator(image); }
		)*
	}

Operator equalityFtn()
	      : { Operator image; }
	{
		( 
			image = equalToken() |
			image = notEqualToken()
		)
		{ return image; }
	}

Operator equalToken()
	      : {}
	{
		<EQUAL>
		{ return Operator.EQ; }
	}

Operator notEqualToken()
	      : {}
	{
		<NOTEQUAL>
		{ return Operator.NEQ;}
	}

/******************************************************************************
 * Add Relational expression and functions
 *****************************************************************************/
void relationalExpr()
	      : { Operator image; }
	{
		arithmeticExpr()
		( 
			image = relationalFtn()/*@bgen(jjtree) #Relational( 2) */
                                                {
                                                  ASTRelational jjtn001 = new ASTRelational(JJTRELATIONAL);
                                                  boolean jjtc001 = true;
                                                  jjtree.openNodeScope(jjtn001);
                                                }
                                                try {
/*@egen*/ arithmeticExpr()/*@bgen(jjtree)*/
                                                } catch (Throwable jjte001) {
                                                  if (jjtc001) {
                                                    jjtree.clearNodeScope(jjtn001);
                                                    jjtc001 = false;
                                                  } else {
                                                    jjtree.popNode();
                                                  }
                                                  if (jjte001 instanceof RuntimeException) {
                                                    throw (RuntimeException)jjte001;
                                                  }
                                                  if (jjte001 instanceof ParseException) {
                                                    throw (ParseException)jjte001;
                                                  }
                                                  throw (Error)jjte001;
                                                } finally {
                                                  if (jjtc001) {
                                                    jjtree.closeNodeScope(jjtn001,  2);
                                                  }
                                                }
/*@egen*/               
			{ ((SimpleNode) jjtree.peekNode()).setOperator(image); }
		)*
	}

Operator relationalFtn()
	      : { Operator image; }
	{ 
		(
			image = lessThanToken() |
			image = greaterThanToken() |
			image = lessThanOrEqualToToken() |
			image = greaterThanOrEqualToToken()
		)
		{ return image; }
	}

Operator lessThanToken()
	      : {}
	{
		<LT>
		{ return Operator.LT; }
	}

Operator greaterThanToken()
	      : {}
	{
		<GT>
		{ return Operator.GT; }
	}

Operator lessThanOrEqualToToken()
	      : {}
	{
		<LTEQ>
		{ return Operator.LE; }
	}

Operator greaterThanOrEqualToToken()
	      : {}
	{
		<GTEQ>
		{ return Operator.GE; }
	}

/******************************************************************************
 * Add Arithmetic expression and function - addition and subtraction have
 * equal precedence
 *****************************************************************************/
void arithmeticExpr()
	      : { Operator image; }
	{
		geometricExpr()
		(
			image = arithmeticFtn()/*@bgen(jjtree) #Arithmetic( 2) */
                                                {
                                                  ASTArithmetic jjtn001 = new ASTArithmetic(JJTARITHMETIC);
                                                  boolean jjtc001 = true;
                                                  jjtree.openNodeScope(jjtn001);
                                                }
                                                try {
/*@egen*/ geometricExpr()/*@bgen(jjtree)*/
                                                } catch (Throwable jjte001) {
                                                  if (jjtc001) {
                                                    jjtree.clearNodeScope(jjtn001);
                                                    jjtc001 = false;
                                                  } else {
                                                    jjtree.popNode();
                                                  }
                                                  if (jjte001 instanceof RuntimeException) {
                                                    throw (RuntimeException)jjte001;
                                                  }
                                                  if (jjte001 instanceof ParseException) {
                                                    throw (ParseException)jjte001;
                                                  }
                                                  throw (Error)jjte001;
                                                } finally {
                                                  if (jjtc001) {
                                                    jjtree.closeNodeScope(jjtn001,  2);
                                                  }
                                                }
/*@egen*/               
			{ ((SimpleNode) jjtree.peekNode()).setOperator(image); }
		)*
	}

Operator arithmeticFtn()
	      : { Operator image; }
	{
		(
			image = plusToken() |
			image = minusToken()
		)
		{ return image; }
	}

Operator plusToken()
	      : {}
	{
		<PLUS>
		{ return Operator.ADD; }
	}

Operator minusToken()
	      : {}
	{
		<MINUS>
		{ return Operator.SUB; }
	}

/******************************************************************************
 * Add Geometric expression and functions - multiplication and both types of
 * division have equal precedence
 *****************************************************************************/
void geometricExpr()
	      : { Operator image; }
	{
		unaryMinusExpr()
		(
			image = geometricFtn()/*@bgen(jjtree) #Geometric( 2) */
                                               {
                                                 ASTGeometric jjtn001 = new ASTGeometric(JJTGEOMETRIC);
                                                 boolean jjtc001 = true;
                                                 jjtree.openNodeScope(jjtn001);
                                               }
                                               try {
/*@egen*/ unaryMinusExpr()/*@bgen(jjtree)*/
                                               } catch (Throwable jjte001) {
                                                 if (jjtc001) {
                                                   jjtree.clearNodeScope(jjtn001);
                                                   jjtc001 = false;
                                                 } else {
                                                   jjtree.popNode();
                                                 }
                                                 if (jjte001 instanceof RuntimeException) {
                                                   throw (RuntimeException)jjte001;
                                                 }
                                                 if (jjte001 instanceof ParseException) {
                                                   throw (ParseException)jjte001;
                                                 }
                                                 throw (Error)jjte001;
                                               } finally {
                                                 if (jjtc001) {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                 }
                                               }
/*@egen*/              
			{ ((SimpleNode) jjtree.peekNode()).setOperator(image); }
		)*
	}

Operator geometricFtn()
	      : { Operator image; }
	{
		(
			image = multToken() |
			image = divToken() |
			image = remToken()
		)
		{ return image; }
	}

Operator multToken()
	      : {}
	{
		<MULT>
		{ return Operator.MUL;}
	}

Operator divToken()
	      : {}
	{
		<DIV>
		{ return Operator.DIV; }
	}

Operator remToken()
	      : {}
	{
		<REM>
		{ return Operator.REM; }
	}

/******************************************************************************
 * Add Unary expression
 *****************************************************************************/
void unaryMinusExpr()
	      : { Token t = null; }
	{
		( t=<MINUS> )?/*@bgen(jjtree) #UnaryMinus( t != null) */
                               {
                                 ASTUnaryMinus jjtn001 = new ASTUnaryMinus(JJTUNARYMINUS);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
                               }
                               try {
/*@egen*/ unaryNotExpr()/*@bgen(jjtree)*/
                               } catch (Throwable jjte001) {
                                 if (jjtc001) {
                                   jjtree.clearNodeScope(jjtn001);
                                   jjtc001 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte001 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte001;
                                 }
                                 if (jjte001 instanceof ParseException) {
                                   throw (ParseException)jjte001;
                                 }
                                 throw (Error)jjte001;
                               } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  t != null);
                                 }
                               }
/*@egen*/                       
		{
		   SimpleNode n = ((SimpleNode) jjtree.peekNode());
		   if (n instanceof ASTUnaryMinus) n.setOperator(Operator.MINUS);
		}
	}

void unaryNotExpr()
	      : { Token t = null; }
	{
		( t=<EXCLAMATION> )?/*@bgen(jjtree) #UnaryNot( t != null) */
                                     {
                                       ASTUnaryNot jjtn001 = new ASTUnaryNot(JJTUNARYNOT);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
                                     }
                                     try {
/*@egen*/ exponExpr()/*@bgen(jjtree)*/
                                     } catch (Throwable jjte001) {
                                       if (jjtc001) {
                                         jjtree.clearNodeScope(jjtn001);
                                         jjtc001 = false;
                                       } else {
                                         jjtree.popNode();
                                       }
                                       if (jjte001 instanceof RuntimeException) {
                                         throw (RuntimeException)jjte001;
                                       }
                                       if (jjte001 instanceof ParseException) {
                                         throw (ParseException)jjte001;
                                       }
                                       throw (Error)jjte001;
                                     } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  t != null);
                                       }
                                     }
/*@egen*/                     
		{
		   SimpleNode n = ((SimpleNode) jjtree.peekNode());
		   if (n instanceof ASTUnaryNot) n.setOperator(Operator.NOT);
		}
	}

/******************************************************************************
 * Add Exponential expression
 *****************************************************************************/
void exponExpr()
	      : {}
	{
		primitiveExpr()
		(
			<POW>/*@bgen(jjtree) #Expon( 2) */
                              {
                                ASTExpon jjtn001 = new ASTExpon(JJTEXPON);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*/ primitiveExpr()/*@bgen(jjtree)*/
                              } catch (Throwable jjte001) {
                                if (jjtc001) {
                                  jjtree.clearNodeScope(jjtn001);
                                  jjtc001 = false;
                                } else {
                                  jjtree.popNode();
                                }
                                if (jjte001 instanceof RuntimeException) {
                                  throw (RuntimeException)jjte001;
                                }
                                if (jjte001 instanceof ParseException) {
                                  throw (ParseException)jjte001;
                                }
                                throw (Error)jjte001;
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                }
                              }
/*@egen*/          
			{ ((SimpleNode) jjtree.peekNode()).setOperator(Operator.EXP); }
		)*
	}


/******************************************************************************
 * Now we're at the productions that will form the leaves of the tree
 *****************************************************************************/
void primitiveExpr()
	      : {}
	{
		parenExpr()       |
		numberExpr()      |
		lookupExpr()
	}

void parenExpr()
	       : {/*@bgen(jjtree) Paren */
  ASTParen jjtn000 = new ASTParen(JJTPAREN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Paren */
                try {
/*@egen*/
		<OPENPAREN> logicalExpr() <CLOSEPAREN>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void numberExpr()
	     : {/*@bgen(jjtree) Num */
                 ASTNum jjtn000 = new ASTNum(JJTNUM);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1 = null, t2 = null, t3 = null; }
	{/*@bgen(jjtree) Num */
                try {
/*@egen*/
		(
			(t1 = <INT> ( LOOKAHEAD(2) t2 = <FULLSTOP> t3 = <INT>)? ) |
			(t1 = <FULLSTOP> t2 = <INT>)
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			String image;
			if (t3 == null) {
				if (t2 == null) {
					image = t1.image;
				} else {
					image = "." + t2.image;
				}
			} else {
				image = t1.image + "." + t3.image;
			}
			jjtn000.setToken(image);
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

/******************************************************************************
 * This is the start of the PCGEN specific stuff.  The "Dot separated words"
 * are used for our OS tokens and in some of our predefined variables.
 *****************************************************************************/
void lookupExpr()
	                 : {/*@bgen(jjtree) #PCGenLookup(> 1) */
  ASTPCGenLookup jjtn000 = new ASTPCGenLookup(JJTPCGENLOOKUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) #PCGenLookup(> 1) */
                try {
/*@egen*/
		pcgenSingleWord() ( pcgenBracketGroup() | parenGroup() )?/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/
	}

void pcgenSingleWord()
	                 : {/*@bgen(jjtree) PCGenSingleWord */
                             ASTPCGenSingleWord jjtn000 = new ASTPCGenSingleWord(JJTPCGENSINGLEWORD);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; Token i = null; }
	{/*@bgen(jjtree) PCGenSingleWord */
                try {
/*@egen*/
		( i = <REM>)? t = <VARIABLE>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			String image;
			if (i == null) {
				image = t.image;
			} else {
			    if (i.image.lastIndexOf(" ") == i.image.length() - 1)
			    {
			        throw new ParseException("Found Word with embedded space: " + i.image + t.image);
			    }
				image = i.image + t.image;
			}
			/*
			 * Cannot enforce spaces on other words, due to Class names allowing spaces
			 */
			jjtn000.setToken(image);
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void pcgenBracketGroup()
	              : {/*@bgen(jjtree) PCGenBracket */
  ASTPCGenBracket jjtn000 = new ASTPCGenBracket(JJTPCGENBRACKET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) PCGenBracket */
                try {
/*@egen*/
		<OPENBRACKET> arithmeticExpr() <CLOSEBRACKET>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void parenGroup()
	        : {/*@bgen(jjtree) FParen */
                    ASTFParen jjtn000 = new ASTFParen(JJTFPAREN);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1; }
	{/*@bgen(jjtree) FParen */
                try {
/*@egen*/
		<OPENPAREN> 
		(functionExpr()
		  (
			<COMMA> functionExpr()
		  )*
		)?
		<CLOSEPAREN>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void functionExpr()
	      : {}
	{
		logicalExpr() | quotedString()
	}

void quotedString()
	            : {/*@bgen(jjtree) QuotString */
                        ASTQuotString jjtn000 = new ASTQuotString(JJTQUOTSTRING);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
	{/*@bgen(jjtree) QuotString */
                try {
/*@egen*/
		t = <STRING_LITERAL>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			String stripped = t.image.substring(1, t.image.length() - 1);
			jjtn000.setToken(stripped);
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}


/******************************************************************************
 * And now the tokens, some of these are general, some of them are PCGEN
 * specific.
 *****************************************************************************/

TOKEN : { < #PERCENT     : "%" > }
TOKEN : { < #COLON       : ":" > }
TOKEN : { < #HYPHEN      : "-" > }
TOKEN : { < #SOLIDUS     : "/" > }
TOKEN : { < #EQUALSIGN   : "=" > }
TOKEN : { < #UNDERSCORE  : "_" > }
TOKEN : { < #TILDE       : "~" > }
TOKEN : { < #SPACE       : " " > }

TOKEN : { < #O_SPACE    : ( <SPACE> )* > }

TOKEN : { < EXCLAMATION  : <O_SPACE> "!"       <O_SPACE> > }
TOKEN : { < PLUS         : <O_SPACE> "+"       <O_SPACE> > }
TOKEN : { < MINUS        : <O_SPACE> <HYPHEN>  <O_SPACE> > }
TOKEN : { < MULT         : <O_SPACE> "*"       <O_SPACE> > }
TOKEN : { < DIV          : <O_SPACE> <SOLIDUS> <O_SPACE> > }
TOKEN : { < REM          : <O_SPACE> <PERCENT> <O_SPACE> > }
TOKEN : { < POW          : <O_SPACE> "^"       <O_SPACE> > }
TOKEN : { < COMMA        : <O_SPACE> ","       <O_SPACE> > }
TOKEN : { < OPENPAREN    : <O_SPACE> "("       <O_SPACE> > }
TOKEN : { < CLOSEPAREN   : <O_SPACE> ")"       <O_SPACE> > }
TOKEN : { < OPENBRACKET  : <O_SPACE> "["       <O_SPACE> > }
TOKEN : { < CLOSEBRACKET : <O_SPACE> "]"       <O_SPACE> > }
TOKEN : { < GT           : <O_SPACE> ">"       <O_SPACE> > }
TOKEN : { < LT           : <O_SPACE> "<"       <O_SPACE> > }
TOKEN : { < GTEQ         : <O_SPACE> ">="      <O_SPACE> > }
TOKEN : { < LTEQ         : <O_SPACE> "<="      <O_SPACE> > }
TOKEN : { < EQUAL        : <O_SPACE> "=="      <O_SPACE> > }
TOKEN : { < NOTEQUAL     : <O_SPACE> "!="      <O_SPACE> > }
TOKEN : { < AND          : <O_SPACE> "&&"      <O_SPACE> > }
TOKEN : { < OR           : <O_SPACE> "||"      <O_SPACE> > }
TOKEN : { < FULLSTOP     :           "."                 > }

TOKEN : { < #DIGIT : ["0" - "9"] > }

TOKEN : { < #BASIC_LETTER : [
       "A"-"Z",  // Uppercase Latin
       "a"-"z",  // Lowercase Latin
       "\u00c0"-"\u00d6",  // Modified Latin (start)
       "\u00d8"-"\u00f6",  // Modified Latin (middle)
       "\u00f8"-"\u00ff",  // Modified Latin (end)
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
]  > }

TOKEN : { < #FINAL_LETTER   : ( <TILDE> |
                                <DIGIT> |
                                <BASIC_LETTER> ) > }

TOKEN : { < #MID_LETTER     : ( <UNDERSCORE> |
                                <SPACE> |
                                <COLON> |
                                <FULLSTOP> |
                                <PERCENT> |
                                <FINAL_LETTER> ) > }

TOKEN : { < VARIABLE        : <BASIC_LETTER> ( ( <MID_LETTER> )* ( <EQUALSIGN> ( <MID_LETTER> )* ) ? <FINAL_LETTER> )? > }

TOKEN : { < INT : ( <DIGIT> )+ > }

TOKEN : { < STRING_FORBIDDEN: (~["\"","\\","\n","\r"]) > }
TOKEN : { < STRING_ESCAPED: ("\\" ( ["n","t","b","r","f","\\","'","\""] ) ) > }
TOKEN : { < STRING_LITERAL: "\"" ( <STRING_FORBIDDEN> | <STRING_ESCAPED> )* "\"" > }